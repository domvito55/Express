<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>This is a Enclosure example</h1>
    <p>This time, the parent() function returned the child()
        function, and the child() function is called after the
        parent() function has already been executed.
    </p>
    <p>This is counterintuitive to some developers because
        usually the parent() function's local members should
        only exist while the function is being executed.
        ÔÅ∂ This is what closures are all about! A closure is not only
        the function, but also the environment in which the
        function was created.
    </p>
    <p>In this case, childFN() is a closure object that consists of
        the child() function and the environment members that
        existed when the closure was created, including the
        message constant.
    </p>
    <p>
        Closures are very important in asynchronous
        programming because JavaScript functions are first-class
        objects that can be passed as arguments to other
        functions.
    </p>
    <p>
        This means that you can create a callback function and
        pass it as an argument to an event handler.
        When the event will be emitted, the function will be
        invoked, and it will be able to manipulate any member
        that existed when the callback function was created, even
        if its parent function was already executed.
    </p>
    <p>
        This means that using the closure pattern will help you
        utilize event-driven programming without the need to pass
        the scope state to the event handler.
    </p>

    <script src="main.js"></script>
</body>
</html>